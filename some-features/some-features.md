## Diffing Customization

https://argoproj.github.io/argo-cd/user-guide/diffing/

Application Level Configuration

Argo CD allows ignoring differences at a specific JSON path, using RFC6902 JSON patches. The following sample application is configured to ignore differences in spec.replicas for all deployments:
```
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: quake-external-dns 
  # You'll usually want to add your resources to the argocd namespace.
  namespace: quake-system
  # Add a this finalizer ONLY if you want these to cascade delete.
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  syncPolicy:
    automated:
      # Specifies if resources should be pruned during auto-syncing ( false by default ).
      prune: true 
      # Specifies if partial app sync should be executed when resources are changed only in target Kubernetes cluster and no git change detected ( false by default ).
      selfHeal: true 
  ignoreDifferences:
  - group: apps
    kind: Deployment
    jsonPointers:
    - /spec/replicas
```

=> xử lý vấn đề canary deployment:
ref:
https://argoproj.github.io/argo-rollouts/features/traffic-management/istio/#integrating-with-gitops
https://github.com/argoproj/argo-cd/issues/2913

more example: https://github.com/argoproj/argo-cd/issues/1815

Ở version mới > 2.1 đã cho phép sử dụng thêm cả jq expression để diễn tả path mình sẽ ignoreDifferences
```
spec:
  ignoreDifferences:
  - group: apps
    kind: Deployment
    jqPathExpressions:
    - .spec.template.spec.initContainers[] | select(.name == "injected-init-container")
```
ref:
https://argo-cd.readthedocs.io/en/latest/user-guide/diffing/


## Ignoring Resources That Are Extraneous

ref: https://argoproj.github.io/argo-cd/user-guide/compare-options/

You may wish to exclude resources from the app's overall sync status under certain circumstances. E.g. if they are generated by a tool. This can be done by adding this annotation on the resource you wish to exclude:

```
metadata:
  annotations:
    argocd.argoproj.io/compare-options: IgnoreExtraneous
```


## Resource hook , Sync phase and wave

ref: 
https://argoproj.github.io/argo-cd/user-guide/resource_hooks/
https://argoproj.github.io/argo-cd/user-guide/sync-waves/

Synchronization can be configured using resource hooks. Hooks are ways to run scripts before, during, and after a Sync operation. Hooks can also be run if a Sync operation fails at any point.
When Argo CD starts a sync, it orders the resources in the following precedence:
  -  The phase
  -  The wave they are in (lower values first)
  -  By kind (e.g. namespaces first)
  -  By name


## Parameter Overrides

https://argoproj.github.io/argo-cd/user-guide/parameters/

Overwrite giá trị ( có thể là helm values) bằng cách truyền params khi dùng argocd cli

## Sync Windows

ref: https://argoproj.github.io/argo-cd/user-guide/sync_windows/

Sync windows are configurable windows of time where syncs will either be blocked or allowed.
=> Config khoảng thời gian allow/deny việc sync

## Applicationset

Dynamic Generate ra application CR object

ref: https://github.com/argoproj-labs/applicationset

## Skip Dry Run for new custom resources types
ref: https://argoproj.github.io/argo-cd/user-guide/sync-options/#skip-dry-run-for-new-custom-resources-types

When syncing a custom resource which is not yet known to the cluster, there are generally two options:

1) The CRD manifest is part of the same sync. Then ArgoCD will automatically skip the dry run, the CRD will be applied and the resource can be created. 2) In some cases the CRD is not part of the sync, but it could be created in another way, e.g. by a controller in the cluster. An example is gatekeeper, which creates CRDs in response to user defined ConstraintTemplates. ArgoCD cannot find the CRD in the sync and will fail with the error the server could not find the requested resource.

To skip the dry run for missing resource types, use the following annotation:
```
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
```

The dry run will still be executed if the CRD is already present in the cluster.

## Webhook and Manifest Paths Annotation

ref: https://argoproj.github.io/argo-cd/operator-manual/high_availability/#webhook-and-manifest-paths-annotation

Argo CD aggressively caches generated manifests and uses repository commit SHA as a cache key. A new commit to the Git repository invalidates cache for all applications configured in the repository that again negatively affect mono repositories with multiple applications. You might use webhooks ⧉ and argocd.argoproj.io/manifest-generate-paths Application CRD annotation to solve this problem and improve performance.

The argocd.argoproj.io/manifest-generate-paths contains a semicolon-separated list of paths within the Git repository that are used during manifest generation. The webhook compares paths specified in the annotation with the changed files specified in the webhook payload. If non of the changed files are located in the paths then webhook don't trigger application reconciliation and re-uses previously generated manifests cache for a new commit.

Installations that use a different repo for each app are not subject to this behavior and will likely get no benefit from using these annotations.

## Enable Concurrent Processing
Argo CD determines if manifest generation might change local files in the local repository clone based on config management tool and application settings. If the manifest generation has no side effects then requests are processed in parallel without the performance penalty. Following are known cases that might cause slowness and workarounds:

Multiple Helm based applications pointing to the same directory in one Git repository: ensure that your Helm chart don't have conditional dependencies and create .argocd-allow-concurrency file in chart directory.

Multiple Custom plugin based applications: avoid creating temporal files during manifest generation and and create .argocd-allow-concurrency file in app directory.

Multiple Kustomize or Ksonnet applications in same repository with parameter overrides: sorry, no workaround for now.

ref:
https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/#enable-concurrent-processing


## Resource health

https://argoproj.github.io/argo-cd/operator-manual/health/

## Custom action

ref:
https://github.com/argoproj/argo-cd/issues/86
https://github.com/argoproj/argo-cd/tree/master/resource_customizations
https://argoproj.github.io/argo-cd/operator-manual/server-commands/argocd-util_settings_resource-overrides_run-action/

Custom Actions
Argo CD introduces Custom Resource Actions to allow users to provide their own Lua scripts to modify existing Kubernetes resources in their applications. These actions are exposed in the UI to allow easy, safe, and reliable changes to their resources. This functionality can be used to introduce functionality such as suspending and enabling a Kubernetes cronjob, continue a BlueGreen deployment with Argo Rollouts, or scaling a deployment.

A use case is to perform some kind of custom action on an application resource. Some example actions are:
- pause / resume an Argo Rollout
- suspend / resume a CronJob
- set some istio traffic shaping weights on a VirtualService

This proposal is to support customized actions on application resources. These actions would be made available from the API and CLI. The "action" would be a lua script that mutates the resource object in some way.

Some considerations:
we may need a way to list available actions on a resource (to present in UI). For example, if a cronjob is suspended, then it should show "resume" as an available action but not "suspend" some actions may require inputs. For example, to set weights for a Istio VirtualService actions may return errors. For example, if someone supplied invalid input to an action

should read:
https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml#L158
https://github.com/argoproj/argo-cd/pull/2375/files

## Argo CD Image Updater

ref: https://argocd-image-updater.readthedocs.io/en/stable/

The Argo CD Image Updater can check for new versions of the container images that are deployed with your Kubernetes workloads and automatically update them to their latest allowed version using Argo CD.


## Selective sync
ref:
https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/

Currently when syncing using auto sync ArgoCD applies every object in the application. For applications containing thousands of objects this takes quite a long time and puts undue pressure on the api server. Turning on selective sync option which will sync only out-of-sync resources.

You can add this option by following ways

1) Add ApplyOutOfSyncOnly=true in manifest

Example:
```
syncPolicy:
  syncOptions:
    - ApplyOutOfSyncOnly=true
```
2) Set sync option via argocd cli

Example:
```
$ argocd app set guestbook --sync-option ApplyOutOfSyncOnly=true
```


## Prune Last
This feature is to allow the ability for resource pruning to happen as a final, implicit wave of a sync operation, after the other resources have been deployed and become healthy, and after all other waves completed successfully.

```
syncOptions:
- PruneLast=true
```

This can also be configured at individual resource level.
```
metadata:
  annotations:
    argocd.argoproj.io/sync-options: PruneLast=true
```


## Skip Dry Run for new custom resources types

When syncing a custom resource which is not yet known to the cluster, there are generally two options:

1) The CRD manifest is part of the same sync. Then ArgoCD will automatically skip the dry run, the CRD will be applied and the resource can be created. 

2) In some cases the CRD is not part of the sync, but it could be created in another way, e.g. by a controller in the cluster. An example is gatekeeper, which creates CRDs in response to user defined ConstraintTemplates. ArgoCD cannot find the CRD in the sync and will fail with the error the server could not find the requested resource.

To skip the dry run for missing resource types, use the following annotation:
```
metadata:
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
```

The dry run will still be executed if the CRD is already present in the cluster.

## Blacklist resources

Ta có thể thêm resource vào blacklist của Project chứa 1 nhóm application
=> Các resource đó khi đó vẫn sẽ có trong helm chart/kustomize nhưng sẽ không được argocd sync
=> Khi đó sẽ có status sync failed với message Resource ... is not permitted in project ...

The blacklisted resources restrict which resources can be deployed by an application but still visible in the user interface.
If Argo CD hides such resources then it might create a false impression that the application is successfully deployed and confuse the user. 

https://github.com/argoproj/argo-cd/issues/2969


## Add external url

https://argo-cd.readthedocs.io/en/stable/user-guide/external-url/

Nếu ở argocd web, ta thấy biểu tượng external url thì đó có thể là do ta add annotation theo link trên.
Hoặc argocd sẽ tự lấy IP public có từ ingress object hoặc service object.